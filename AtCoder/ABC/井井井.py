n,m = map(int,input().split())
X = list(map(int,input().split()))
Y = list(map(int,input().split()))
area=0
mod=10**9+7

x=0

for i in range(n):
  x += -(n-i-1)*X[i]+i*X[i] #引き算の総和を引いている（たすだけのものはたしている）

y = 0

for i in range(m):
  y += -(m-i-1)*Y[i]+i*Y[i] #引き算に総和を引いている（たすだけのものはたしている）

print(x*y%mod)

#x軸の選び方がm*(m-1)/2,y軸がn*(n-1)/2、よって長方形の面積計算はO(m^2*n^2)で当然のTLE。
#サンプル１を例にして考える。
#まずx軸の辺は2,1,3の3通り(m*(m-1)/2=3)、同様にy軸は2,3,5。
#ans=2*2+2*3+2*5+1*2+1*3+1*5+3*2+3*3+3*5=60
#上記の式はans=(2+1+3)*(2+3+5)=60と変形できることに気付く。これでO(m|n^2)まで計算量を落とせる。
#ただし、m<=10**5なので、まだTLE。ここでm*(m-1)/2通りの各辺の長さを効率的に求めることを考える。
#m0,m1,m2がソートされていたとして、3通りの辺はm2-m0, m2-m1 ,m1-m0。
#ここで各点が加算に使われる場合と減算に使われる場合に法則があると気付く。
#具体的に長さNの数列において、点iが加算に使われる回数はi回,減算に使われる回数は(N-i-1)回 (0オリジンで考えている)
#つまりans+=A[i]*i-A[i]*(N-i-1)としてi=0~N-1までの総和を取ればよいことが分かる。
#これはO(N)なので、全体としてO(N+N)=O(N)で答えを求められると思われる。


