n,m=map(int,input().split())
imos=[0]*(m+2) #宝石の種類カウント
total=0
for i in range(n):
  l,r,s=map(int,input().split())
  imos[l]+=s
  imos[r+1]-=s
  total+=s
for i in range(m):
  imos[i+1]+=imos[i]
print(total-min(imos[1:-1]))

"""
m種類のアイテムのうち少なくとも一つは数字が覆われていない時の他の得点の合計
→覆っていない数字Xを固定して考える
⑴与えられた区間がXを覆っている場合：その区間は採用できない
⑵与えられた区間がXを覆っていない場合：その区間を採用できる
→⑵を全て採用した時の合計

Xを覆っていない区間の合計得点を求める<=>全体の合計得点からXを覆っている区間の合計点のうち最小のXを引くに変換
これを実現するデータ構造
・ある連続した領域に同じ値を足す
・特定の一要素の値を求める
→いもす法：
array[l]からarray[r]までの区間にsずつ足したい場合に、
全てに一つずつ足すのではなく、array[l]だけにsを足して、array[r+1]に-sを足す。

"""
